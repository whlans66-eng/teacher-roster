# 🔧 資料衝突問題修復說明

## ❌ 原始問題

### 問題描述
當多人同時使用系統時，會發生**資料覆蓋**問題：

```
時間線：
1. A、B、C 三人同時開啟網頁，各自從 Google Sheets 載入資料
2. A 新增資料並儲存（成功同步到 Google Sheets）
3. A 關閉網頁
4. B 或 C 關閉網頁時，他們的舊資料覆蓋了 Google Sheets
5. 結果：A 的新資料消失了！❌
```

### 根本原因
- 每個人的 localStorage 只在開啟時載入一次
- 當其他人修改資料後，已開啟的頁面不知道有更新
- 關閉頁面時會用舊資料覆蓋新資料（Last Write Wins）

---

## ✅ 修復方案

### 已實施的修復

#### 1️⃣ **安全儲存模式**
新增 `saveToBackendSafe()` 函數，在儲存前檢查衝突：

```javascript
// 儲存前先檢查後端是否有更新
const backendData = await this.api.listAll();

// 如果後端資料比本地多，表示有其他人的更新
if (後端有更新) {
  alert('⚠️ 後端有其他人的更新，請重新整理頁面後再儲存');
  return; // 拒絕儲存，防止覆蓋
}
```

#### 2️⃣ **修改標記機制**
只有真正修改過資料的人才會儲存：

```javascript
// 當用戶修改資料時
syncManager.markAsChanged(); // 標記「我有修改」

// 儲存時檢查
if (!hasLocalChanges) {
  return; // 沒修改就不儲存，避免覆蓋
}
```

#### 3️⃣ **衝突提示**
當偵測到衝突時，會提示使用者：

```
⚠️ 後端有其他人的更新，請重新整理頁面後再儲存
```

---

## 🧪 測試情境

### 情境 1：正常使用（無衝突）
```
A 開啟頁面 → 修改資料 → 儲存 ✅
B 開啟頁面 → 修改資料 → 儲存 ✅
結果：兩人的資料都保存了
```

### 情境 2：同時修改（有衝突）
```
A 和 B 同時開啟頁面
A 新增「老師3」→ 儲存 ✅
B 新增「老師4」→ 嘗試儲存
  → ⚠️ 系統偵測：後端有 A 的更新
  → ❌ 拒絕儲存，提示 B 重新整理
B 重新整理頁面 → 看到「老師3」
B 再次新增「老師4」→ 儲存 ✅
結果：兩人的資料都保存了（透過重新整理解決）
```

### 情境 3：只瀏覽不修改
```
A 開啟頁面 → 修改資料 → 儲存 ✅
B 開啟頁面 → 只瀏覽，沒修改 → 關閉頁面
  → ✅ 系統偵測：B 沒有修改，跳過儲存
結果：A 的資料保持完整
```

---

## 📋 使用建議

### ✅ 最佳實踐

1. **修改前先重新整理**
   - 開始工作前，按 F5 重新整理取得最新資料

2. **修改後立即儲存**
   - 完成修改後立刻儲存，不要延遲

3. **看到衝突提示時**
   - 按照提示重新整理頁面
   - 確認資料後再重新修改

4. **定期重新整理**
   - 如果長時間開啟頁面，建議每 10-15 分鐘重新整理一次

### ⚠️ 仍可能發生衝突的情況

即使有防護機制，以下情況仍可能造成問題：

1. **同時修改同一筆資料**
   - A 修改「老師1」的電話
   - B 同時修改「老師1」的信箱
   - 最後儲存的人會覆蓋前一個人的修改

2. **極短時間內的並發儲存**
   - 如果兩人在 1 秒內同時按儲存
   - 系統可能來不及偵測衝突

---

## 🚀 進階解決方案

如果你的團隊經常遇到衝突，建議升級到專業架構：

### 方案 1：自動重新整理（簡單）

在頁面加入自動重新載入：

```javascript
// 每 3 分鐘自動從後端重新載入資料
setInterval(async () => {
  const latest = await syncManager.loadFromBackend();
  updateAllViews(); // 重新渲染頁面
  console.log('🔄 資料已自動更新');
}, 3 * 60 * 1000);
```

### 方案 2：即時同步（推薦）

使用 Firebase Firestore，提供真正的即時同步：

```javascript
// 所有用戶自動看到最新資料
onSnapshot(collection(db, "teachers"), (snapshot) => {
  teachers = snapshot.docs.map(doc => doc.data());
  updateUI(); // 自動更新，無需重新整理
});
```

### 方案 3：MySQL + Docker（專業）

完整的後端架構，支援真正的資料庫鎖機制：

- 事務處理（Transaction）
- 樂觀鎖（Optimistic Locking）
- 悲觀鎖（Pessimistic Locking）
- 版本控制（Versioning）

詳見：`MYSQL_DOCKER_GUIDE.md`

---

## 📊 修復效果比較

| 情況 | 修復前 | 修復後 |
|------|--------|--------|
| A 修改，B 沒修改，B 後關閉 | ❌ A 的資料消失 | ✅ A 的資料保留 |
| A、B 同時修改不同資料 | ❌ 先儲存的人的資料消失 | ⚠️ 提示衝突，要求重新整理 |
| A、B 同時修改同一筆資料 | ❌ 先儲存的人的資料消失 | ⚠️ 提示衝突（但最後儲存的人仍會覆蓋） |
| 長時間開啟頁面 | ❌ 看不到其他人的更新 | ⚠️ 需手動重新整理 |

---

## 🔍 監控和除錯

### 查看主控台訊息

開啟瀏覽器開發者工具（F12），查看以下訊息：

```
✅ 資料已安全儲存到雲端        - 儲存成功
⚠️ 警告：後端有更新的資料！    - 偵測到衝突
⏭️ 本地無修改，跳過儲存        - 沒有修改，不儲存
🔖 標記資料已修改              - 記錄修改動作
```

### 檢查修改標記

在主控台執行：

```javascript
// 檢查是否有標記為修改
localStorage.getItem('hasLocalChanges'); // 'true' 或 null

// 手動清除標記（除錯用）
localStorage.removeItem('hasLocalChanges');
```

---

## 📝 總結

✅ **已修復：** 無修改的人關閉頁面不會覆蓋資料
✅ **已加入：** 衝突偵測機制
✅ **已加入：** 修改標記系統
⚠️ **仍需注意：** 同時修改相同資料仍可能衝突
💡 **建議：** 定期重新整理頁面，獲取最新資料

---

**最後更新：** 2025-11-02
**適用版本：** v1.1.0+
